---
layout:     post
title:      'MySQL索引'
subtitle:   ''
date:       2018-02-26
author:     xiezg247
header-img: "img/post-bg-sample.jpg"
catalog: true
tags:
    - mysql
    - 数据库
---


#### MySQL 优化

##### 1. 索引

- 目的

索引的目的在于提高查询效率。

- 原理

通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。

- 分类
  - index ----普通的索引,数据可以重复
  - fulltext----全文索引，用来对大表的文本域(char，varchar，text)进行索引。语法和普通索引一样
  - unique ----唯一索引,唯一索引,要求所有记录都唯一
  - primary key ----主键索引,也就是在唯一索引的基础上相应的列必须为主键

- 什么情况下需要建立索引
  - 较频繁地作为查询条件的字段
  - 唯一性太差的字段不适合建立索引
  - 更新太频繁地字段不适合创建索引
  - 不会出现在where条件中的字段不该建立索引

- 建索引的几大原则
  - 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
  - =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式
  - 尽量选择区分度高的列作为索引,区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录
  - 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’);
  - 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可
- 工具
  - explain命令
- 慢查询优化的基本步骤
  - 先运行看看是否真的很慢，注意设置SQL_NO_CACHE
  - where条件单表查，锁定最小返回记录表。这句话的意思是把查询语句的where都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高
  - explain查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）
  - order by limit 形式的sql语句让排序的表优先查
  - 了解业务方使用场景
  - 加索引时参照建索引的几大原则
  - 观察结果，不符合预期继续从0分析

2. 隔离级别

   [真正理解Mysql的四种隔离级别](https://www.jianshu.com/p/8d735db9c2c0)

3. 性能瓶颈

   [mysql性能瓶颈分析、性能指标、指标搜集方法与性能分析调优工具](https://www.cnblogs.com/ToDoToTry/p/4392288.html)

4. 性能调优

   [MySQL 性能调优的10个方法](https://www.cnblogs.com/claireyuancy/p/7258314.html)

   [MYSQL性能优化的最佳20+条经验](https://www.cnblogs.com/zhouyusheng/p/8038224.html)
